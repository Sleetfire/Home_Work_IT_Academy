package secondTask;

//2.1 5 + 2 / 8
//2.2 (5 + 2) / 8
//2.3 (5 + 2++) / 8
//2.4 (5 + 2++) / --8
//2.5 (5 * 2 >> 2++) / --8
//2.6 (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8
//2.7 (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8
//2.8 6 - 2 > 3 && 12 * 12 <= 119
//2.9 true && false

public class Operators {

    public static void main(String[] args) {

        int count8 = 8, count2 = 2;
        int a = 5 + 2 / 8; // 5, так как деление имеет более высокий приоритет, чем сложение
        // поэтому сначала будет вычислено 2 / 8 = 0 (округление в меньшую сторону), а потом 5 + 0 = 5

        int b = (5 + 2) / 8; // 0, так как сначала будет вычисляться значение в скобках (равно 7), а потом деление
        // (скобки имеют более высокий приоритет). Получается, что 7 / 8 < 1, а так как округление в меньшую сторону
        // получаем 0

        int c = (5 + count2++) / 8; // 0, так как сначала выполняется действие в скобках, затем инкремент, но
        // так как у него постфиксная форма, значение count2 сразу же не изменится, поэтому результат в скобках
        // будет равен 7, затем мы 7 делим на 8 и получаем значение меньше 1, что округляется в меньшую сторону,
        // то есть к нулю

        count2 = 2;
        int d = (5 + count2++) / --count8; // 1, здесь в скобках получается такое же значение, как в прошлом примере,
        // Но так как декремент имеет более высокий приоритет, чем деление, сначала будет выполнен он (также учитывается
        // его префиксная запись). В итоге имеем, что 7 мы делим на 7 и получаем 1.

        count8 = 8;
        count2 = 2;
        int e = (5 * 2 >> count2++) / --count8; // 0, так как выражение в скобках всегда будет меньше 7.
        // Первым выполняется инкремент (постфиксная форма), затем умножение, после чего будет выполнен побитовый
        // сдвиг вправо. Потом выполнится декремент для count8, последним действием будет деление результата в скобках
        // на 7.

        count8 = 8;
        count2 = 2;

        int f = (5 + 7 > 20 ? 68 : 22 * 2 >> count2++) / --count8; // 1, так как сначала выполняется операции в скобках, затем будет находиться произведение 22 * 2 = 44,
        //После чего будет найдена сумма 5 + 7 = 12. Потом будет выполнен побитовый сдвиг 44 на 2. Последней операцией в скобках будет выполнен тернарный оператор. 
        //Так как 12 не больше, чем 20, тогда выражение в скобках будет равно 11. Потом выполнится инкремент и последним действием выполнится частное 11 /7 = 1.

        count8 = 8;
        count2 = 2;
        //int g = (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> count2++) / --count8; // ошибка компиляции, так как в тернарном
        //операторе типы выражения1 (68 >= 68) и выражения2(22 * 2 >> count2++) отличаются. С boolean нельзя
        // выполнять арифметические операции.

        boolean h = 6 - 2 > 3 && 12 * 12 <= 119; // false, так как выражение (6 - 2 > 3) истинное, а выражение
        // (12 * 12 <= 119) ложное. Если использовать &&, то по таблице истинности оба выражения должны быть true

        boolean i = true && false; // false, так как по таблице истинности оба значения должны быть true.

    }

}
